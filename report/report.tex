\documentclass[10pt,a4paper]{report}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{color, soul}

\usepackage{xcolor}
\usepackage{listings}

\usepackage{xparse}

\NewDocumentCommand{\keyword}{v}{%
\texttt{\textcolor{blue}{#1}}%
}

\NewDocumentCommand{\simplecode}{v}{%
\texttt{\textcolor{black}{#1}}%
}

\begin{document}
  \section*{WACC Project Report}


  \subsection*{1. The Final Product}
  \textit{An analysis and critical evaluation of the quality of the WACC compiler
  have built. You should consider both whether it meets the functional
  specification of the project and whether you judge that it forms a sound basis
  for future development. You may also wish to address the performance
  characteristics of your compiler.}

  We deemed our implementation of the WACC compiler to have completed the
  functional requirements of the specification to a satisfactory degree, as
  evidenced by the test results, in addition to which we also included
  additional test cases for edge cases that were not covered by the original set.
  Our implementation of the WACC compiler also provided us with a expandable
  platform from with additional functionalities, and language features can be
  added. The lexer and parser can easily be expanded to include new language
  features. The syntactic and semantic analysis, owing to our design choices in
  the implementation of errors as bundles, allows for the easy addition of new
  syntax and semantic error types, under new conditions, whilst maintaining the
  ability to gather all thrown error messages in one compilation attempt.
  Our design choice surrounding machine code generation also allows for
  additional arm instructions to be implemented into the compiler, whether it is
  to replace previous implementations or as part of a new language feature.

  \hl{Performance characteristics of our compiler?}


  \subsection*{2. Project Management}
  \textit{An analysis of the organization of your group and your use of project
  management tools (such as Git). You should describe how your group was
  structured, how you coordinated your work and detail any tools that
  helped/hindered your progress. You should also discuss what went well and what
  you would do differently if you were to do the lab again.}

  \subsection*{3. Design Choices and Implementation Details}
  \textit{An analysis of the design choices that your made during the WACC
  project, including your implementation and language and tool choices (with
  justifications), and any interesting issues you had to overcome during the
  implementation of your compiler. You should discuss the design patterns you
  used when designing your code and why you chose to use them. You might also
  want to provide a system architecture diagram for your compiler to aid this
  discussion.}\\
  Before we started our implementation, we did some research over several candidate languages, and we chose Kotlin because it is
  fully interoperable with the Java code generated by Antlr, and its more concise syntax, compared with Java, can reduce the amount 
  of boilerplate code. The project build tool we chose is Gradle, since it is the most popular and stable Kotlin project builder.

  The general structure of our design is similar to the classical compiler's structure: the parser parses the input file and generates
  an abstract syntax tree(AST). The AST is traversed by the semantic analyzer to check for errors and generate a symbol table.
  Then the code generator takes the AST and the symbol table, produces a list of intermediate representation of ARM instructions.
  However, all registers in the IR are not real registers, and it does not contain any push or pop to normal registers. Thus, before the
  final code emission, a register allocator is responsible for scanning through the generated ARM instructions, unify each virtual 
  register to real registers and insert push and pop instructions where necessary.

  // TODO: design patterns

  \subsection*{4. Beyond the Specification}
  We have designed several language extensions to the vanilla WACC language, and named our new language AWSL (acronym for "Another WACC-Style Language").
  A number of backend improvements on code generation are also added to our compiler to generate more efficient code.
  \subsection*{Language Extensions}

  \subsubsection*{0. Basic Syntax and Semantics Improvements}
  AWSL has several improvements in the basic syntax and semantics compared with vanilla WACC. Statements in AWSL are separated and optionally
  ended with semicolons. The \keyword{call} keyword for a function call is optional. Function calls, array literals and newpair constructors 
  are treated as normal expressions. Direct-call statement is also added to AWSL, in case when the user wants to call a function and does not
  care about the return value of it.

  \subsubsection*{1. Constants}
  Any variables defined with \keyword{const} is said to be constant. Any attempt to write to a constant results in a semantic error being thrown at compile time.
  However, write to any member of a const struct or any member of a const array is valid. 

  \subsubsection*{2. Extra Conditional Control Flow}
  AWSL provides support to several extra conditional control flow statements/expression, including multi-case if-statements, if-statements
  without else branch, for-loops, when-clauses (see union types) and ternary if-expressions. 

  \subsubsection*{3. User-defined Struct Types, Tagged Union Types and When-clause}
  AWSL allows users to define their own types. User may either defined a simple struct type, or a tagged union type.\\
  A struct type, just like \simplecode{struct} in C, contains one or several members. Each member of a struct is mutable and
  direct-accessable via \simplecode{<variable>.<member_name>}.\\
  A union type, just like ADTs in haskell, is defined by tags and each tag's members. Any direct access to a member of a union is
  invalid as this operation is unsafe (hence each member of a union is implicitly immutable). The only way to get value of any member
  from a union is via a when-clause, which pattern-matches a union and gets the values of its members.\\
  Each definition of a struct type and each tag of any union type implicitly generates a constructor function, shares the same name aspect
  the corresponding struct type or union tag.

  \subsubsection*{4. Generics and Traits}
  Generical types are also allowed in AWSL. A definition of type \simplecode{List<A>} allows user to define any variable/expression 
  of type \simplecode{List<int>}, \simplecode{List<bool>}, \simplecode{List<List<pair(int, char)>>}, etc.\\
  Trait is an important aspect of AWSL. A type is deemed to be an instance of a Trait, provided that all relevant implementations of
  the trait's required functions for that type is in the program, and all of its generics meets their requirements declared
  in the implementation to the trait. Type of any functions' parameter can be (or contain) a type variable 
  which implements certain traits (or no trait) instead of a concrete type. This provides a better abstraction of the code and 
  drastically increases the code reusability. 

  \subsubsection*{5. Type Inference}
  Instead of direct type-checking, AWSL performs type-inference for expressions to validate their types. During semantic analysis, the
  compiler traverses through each sub-expression of the expression, and try to infer a type meets the expectation for it. 
  It is crucial that each expression in AWSL must be deduced to either a ground type or contains a type variable that is defined in the 
  header of the current function. Otherwise, a semantic error will be thrown by the compiler.\\
  The type-inference feature of AWSL allows users to not specify the type of the variable on its declaration. In such case the compiler would 
  attempt to infer the type of the variable from the rhs expression.

  \subsubsection*{6. Full Pair Type}
  In AWSL, nested pair types do not lose any type information. To make AWSL more compatible to vanilla WACC, \keyword{pair} in AWSL represents
  a pair type with both of its elems' types being implicit. Notice that the semantic meaning of \keyword{pair} in AWSL differs from that in WACC. 
  When \keyword{pair} is appeared in the function header, it is impossible to deduce any type information about either element of that pair as 
  per the semantics of AWSL.


\end{document}